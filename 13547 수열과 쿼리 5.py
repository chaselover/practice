def tree_update(i,diff):
	while i<=N:
		tree[i]+=diff
		i+=i&-i
def tree_sum(i):
	r=0
	while i:
		r+=tree[i]
		i&=i-1
	return r
import sys
input=sys.stdin.readline
N=int(input())
tree=[0]*(N+5)
a=[0]*1000005
b=[0]*(N+5)
for idx,i in enumerate(map(int,input().split())):
	b[idx+1]=a[i]
	a[i]=idx+1
M=int(input())
query=[tuple(map(int,input().split()))+(i,)for i in range(M)]
query.sort(key=lambda x:x[1])
ans=[0]*M
cur=0
for i in range(1,1+N):
	if b[i]:
		tree_update(b[i],-1)
	tree_update(i,1)
	while cur<M:
		if query[cur][1]!=i:break
		ans[query[cur][2]]=tree_sum(query[cur][1])-tree_sum(query[cur][0]-1)
		cur+=1
print(*ans,sep='\n')

# Fenwick
# Fast IO (only use in integer input)

import os,io
input=io.BytesIO(os.read(0,os.fstat(0).st_size)).readline

# Fenwick Tree to Calculate Sum

N = int(input())

MaxLength = N
FenwickTree = []

CurLen = MaxLength
while CurLen != 0:
    FenwickTree.append([0] * CurLen)
    CurLen //= 2

Depth = len(FenwickTree)

def addElem(n,index): # add n to an element in index
    for j in range(Depth):
        if index < len(FenwickTree[j]):
            FenwickTree[j][index] += n
        index //= 2

def firstNSum(n): # Return the sum of the first n elements (0 to n-1)
    nCpy = n
    summ = 0
    depthCur = 0
    while nCpy != 0:
        if nCpy % 2 != 0:
            summ += FenwickTree[depthCur][nCpy - 1]
        nCpy //= 2
        depthCur += 1
    return summ

c = list(map(int,input().split()))
compression = {}
cnt = 1
cNew = []
for i in range(N):
    if c[i] in compression:
        cNew.append(compression[c[i]])
    else:
        compression[c[i]] = cnt
        cNew.append(cnt)
        cnt += 1
c = cNew
firstLocColor = [-1] * N
Q = int(input())
ans = [-1] * Q
queries = []
for i in range(Q):
    l,r = map(int,input().split())
    queries.append((l,r,i))
queries.sort(key = lambda x: x[1])
queryIndex = 0
for i in range(N):
    # Update the Fenwick tree to count ith element
    if firstLocColor[c[i] - 1] == -1:
        addElem(1,i)
        firstLocColor[c[i] - 1] = i
    else:
        addElem(-1,firstLocColor[c[i] - 1])
        addElem(1,i)
        firstLocColor[c[i] - 1] = i
    
    # get query
    while queryIndex < Q and queries[queryIndex][1] - 1 <= i:
        if queries[queryIndex][1] - 1 == i:
            ans[queries[queryIndex][2]] = firstNSum(queries[queryIndex][1]) - firstNSum(queries[queryIndex][0] - 1)
        queryIndex += 1

for elem in ans:
    print(elem)

# 3번
import sys

N_ = int(sys.stdin.readline())
lst_ = list(map(int, sys.stdin.readline().split()))

M_ = int(sys.stdin.readline())
C_ = 1000
grd_quary = [[] for _ in range(C_)]
lst_quary = []
lst_answer = [0 for _ in range(M_)]
for idx_quary in range(M_):
    ptr_s, ptr_e = map(int, sys.stdin.readline().split())
    lst_quary.append((ptr_s - 1, ptr_e - 1, idx_quary))

lst_quary.sort(key=lambda x: x[1])
lst_quary.sort(key=lambda x: x[0] // C_)

lst_count = [0 for _ in range(1000001)]
count_ = 0
ptr_curr_s = lst_quary[0][0]
ptr_curr_e = ptr_curr_s - 1

for ptr_s, ptr_e, idx_quary in lst_quary:
    while ptr_curr_s != ptr_s:
        if ptr_curr_s < ptr_s:
            val_ = lst_[ptr_curr_s]
            ptr_curr_s += 1
            if lst_count[val_] == 1:
                count_ -= 1
            lst_count[val_] -= 1
        else:
            ptr_curr_s -= 1
            val_ = lst_[ptr_curr_s]
            if lst_count[val_] == 0:
                count_ += 1
            lst_count[val_] += 1

    while ptr_curr_e != ptr_e:
        if ptr_curr_e < ptr_e:
            ptr_curr_e += 1
            val_ = lst_[ptr_curr_e]
            if lst_count[val_] == 0:
                count_ += 1
            lst_count[val_] += 1

        else:
            val_ = lst_[ptr_curr_e]
            ptr_curr_e -= 1
            if lst_count[val_] == 1:
                count_ -= 1
            lst_count[val_] -= 1

    lst_answer[idx_quary] = count_

for each_ in lst_answer:
    print(each_)


"""Solution code for "BOJ 13547. 수열과 쿼리 5".

- Problem link: https://www.acmicpc.net/problem/13547
- Solution link: http://www.teferi.net/ps/problems/boj/13547

(This code was generated by Import Inliner v0.1)
"""

import sys
from typing import Iterable, Union


# >>>[BEGIN] teflib.fenwicktree.FenwickTree [v1.3] (Copied from teflib/fenwicktree.py)<<<
class FenwickTree:
    """Fenwick tree for sum operation."""

    def __init__(self, nums_or_size: Union[Iterable[float], int]):
        if isinstance(nums_or_size, int):
            self._size = nums_or_size
            self._arr = [0] * nums_or_size
            self._tree = [0] * nums_or_size
        else:
            self._arr = list(nums_or_size)
            self._size = len(self._arr)
            self._tree = self._arr[:]
            for i, num in enumerate(self._tree):
                if i | (i + 1) < self._size:
                    self._tree[i | (i + 1)] += num

    def update(self, pos: int, num: float):
        self._arr[pos] += num
        while pos < self._size:
            self._tree[pos] += num
            pos |= pos + 1

    def set(self, pos: int, num: float):
        self.update(pos, num - self._arr[pos])

    def get(self, pos: int) -> float:
        return self._arr[pos]

    def query(self, beg: int, end: int) -> float:
        res = 0
        l, r = beg - 1, end - 1
        while r >= 0:
            res += self._tree[r]
            r = (r & (r + 1)) - 1
        while l >= 0:
            res -= self._tree[l]
            l = (l & (l + 1)) - 1
        return res
# >>>[END] teflib.fenwicktree.FenwickTree [v1.3]<<<


def main():
    N = int(sys.stdin.readline())
    A = [int(x) for x in sys.stdin.readline().split()]
    queries = [[] for _ in range(N)]
    M = int(sys.stdin.readline())
    for query_num in range(M):
        i, j = [int(x) for x in sys.stdin.readline().split()]
        queries[j - 1].append((i - 1, query_num))

    last_pos = dict()
    fenwick = FenwickTree(N)
    answers = [None] * M
    for i, a_i in enumerate(A):
        try:
            fenwick.update(last_pos[a_i], -1)
        except KeyError:
            pass
        fenwick.update(i, 1)
        last_pos[a_i] = i
        for l, query_num in queries[i]:
            answers[query_num] = fenwick.query(l, i + 1)

    print(*answers, sep='\n')


if __name__ == '__main__':
    main()


