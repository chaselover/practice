import sys
input = sys.stdin.readline

n = int(input())

# dp: 비트 정보, 자릿 수, 끝나는 수
dp = [[[0] * 10 for _ in range(101)] for _ in range(1 << 10)]

# 처음 시작값을 1로 초기화(어떤 숫자로 시작하는지에 따른 경우의수.모두 1씩 주고 시작.)
for i in range(1, 10):
    dp[1<<i][0][i] = 1

# 자릿수 만큼 순회
for i in range(1, n):
    # 0 ~ 9까지 순회
    for e in range(10):
        # 모든 비트의 대하여 순회
        # 예를 들어, i=3라고 하자. (3번쨰 순회)
        # 3으로 끝났는데 비트가 000000110인경우가 있다고 하자. e가 3이면서 비트가 000001110을 구하고자 한다.
        # 그렇다면, (4,000000110) 과 (2,000000110)인 경우를 더하는 수가 될 것이다. 3으로 끝나고 000000110 -> 000001110즉 3에서 4를 추가하고싶다면
        # 1024는 계단의 숫자를 썻는지 안썼는지에 대한 경우의 수. 거기에 저장하는건. 그 전 자릿수가 +1이나 -1로 끝난것의 합을 모두 더해주는것.
        for bm in range(1024):
            # 0과 9는 앞뒤로 한칸씩 밖에 못더해줌 즉 0은 e<9의 전자릿수 1에서의 합만 받고 9는 e>0의 전자릿수 8의 합만 받음.
            if e < 9:
                dp[bm | (1<<e)][i][e] = (dp[bm | (1<<e)][i][e] + dp[bm][i-1][e+1]) % 1000000000
            if e > 0:
                dp[bm | (1<<e)][i][e] = (dp[bm | (1<<e)][i][e] + dp[bm][i-1][e-1]) % 1000000000

# 그래서 1111111다 켜지고 자릿수가 n인 dp의 값을 모두 더해주면 됨(0~9로 끝나는 모든 경우의수의 값의 합.)
print(sum(dp[1023][n-1]) % 1000000000)